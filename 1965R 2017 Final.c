#pragma config(Sensor, dgtl1,  DFLenc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Aenc,           sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  CLenc,          sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  CRenc,          sensorQuadEncoder)
#pragma config(Sensor, dgtl11, DFRenc,         sensorQuadEncoder)
#pragma config(Motor,  port2,           CR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           CL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           A1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           A2R,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           A2L,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           A3,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           DR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DL,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
wiring directions:
switch port 3 and 9 on cortex
put port5(A2R), port6(A2L), port8(DR) on power expander
*/

#include <Vex_Competition_Includes.c>
//*!!Code used to configure robot for 'VEX' robotics match                       !!*//

/*
* Developed:
*      For: Edmund Fitzgerald, the robot
*      By: SharkRado Robotics, Team 1965R
*
* Copyright:
*      (c) 2017 SharkRado Robotics
*      Adlai E. Stevenson High School VEX Robotics Team 1965R
*
* PID Documentation:
*      (c) 2017 SharkRado Robotics
*      Explains PID and the PID Function Implementation

Edmund B. Fitzgerald: Former President of The Northwestern Mutual Life Insurance Company
Or, The Iron Ore Cargo Ship that sank in November 1975 - also named after the former

VIEW OF ROBOT:

A1  |=--=| A1
|=++=|
AL2 |=--=| AR2
|=--=|
A3  |=--=| A3
______________
DL|||    |||DR

*/

/*
* Direction
* Definitions
*/

// Base Movement Directions
enum Dir
{
	FORWARD,
	BACKWARD,
	LEFT,
	RIGHT,
	CW,
	CCW
};

/*
* Distance
* Measurement
* Definitions
*/
/////////////////////////////////////////////////         CONSTANTS         ////////////////////////////////////////////
// Wheel Diameter
const float WHEEL_DIAMETER = 4.0;

// Base Dimentions, Center of Wheel to Center of Wheel
// Please Update when the Wheel Spacing Changes
// Distance Left to Right
const float BASE_X_DIST = 13.25;
// Distance Front to Back
const float BASE_Y_DIST = 12.0;

// Arm Gear Ratio For Encoder (Output/Input)
const float ARM_GEAR_RATIO = 1.0;

// Maximum and Minimum Arm Angle
const float ARM_MAX_ROTATION = 102.5 * ARM_GEAR_RATIO;
const float ARM_MIN_ROTATION = 0 * ARM_GEAR_RATIO;
const float ARM_LOW_FENCE_ANGLE = 64 * ARM_GEAR_RATIO;
const float ARM_HIGH_FENCE_ANGLE = 69 * ARM_GEAR_RATIO;
const float ARM_MID_ANGLE = 48 * ARM_GEAR_RATIO;

// Claw Gear Ratio For Encoder (Output/Input)
const float CLAW_GEAR_RATIO = 1.0;

// Maximum and Mimimun Claw Angle
const float CLAW_MAX_ROTATION = 999 * (CLAW_GEAR_RATIO);
const float CLAW_MIN_ROTATION = -999 * (CLAW_GEAR_RATIO);

//number of iteration pid continues after setpoint is reached
//this is necessary because it may overshoot/oscilate slightly
//control needs time to stabalize
const int DRIVE_EXTRA_IT = 5;
const int DRIVE_CLOSE_ENOUGH = 10;

/*
* Power
* Limit
* Definitions
*/

// Claw
const float CLAW_POWER_LIMIT = 127;

// Arm
static float ARM_POWER_LIMIT = 127;

// Drive
// Speed Motor Limit: Current Value
// Torque Motor Limit: 127
const float DRIVE_POWER_LIMIT = 127;

const float TURN_CONST = 6.0;

/////////////////////////////////////////////////         Non-Constants         ////////////////////////////////////////////

static float armSetPoint; // degrees
static float driveSetPointR; // inches
static float driveSetPointL;// inches
static float clawSetPoint; // degrees

bool clawPIDRunning = true;
bool armPIDRunning = true;
bool isDriveDone = true;

short autonArmPower = 0;
short autonDrivePower = 0;

bool isAuton = false;

/*
* Value Limitation
* Function
*/

// Used to Limit Power and Target Settings
// Input the Original Value, Upper Limit, and Lower Limit
float limit(float &input, float limitUpper, float limitLower)
{
	if (input > limitUpper) input = limitUpper;
	if (input < limitLower) input = limitLower;
	return input;
}

float limit(short &input, short limitUpper, short limitLower)
{
	if (input > limitUpper) input = limitUpper;
	if (input < limitLower) input = limitLower;
	return input;
}

/*
* PID
* Function
*/

// Main PID Function Called Throughout the Code
// Please See Included Documentation of the PID Function for Explanation of Inputs, and PID itself
const float INTEGRAL_ACTIVE_ZONE = 25.0;
// derivative must oppose motion
float pid(float kp, float ki, float kd, float target, float &error, float &errorTotal, float &prevError, float sensVal, long dt)
{
	error = target - sensVal;
	errorTotal += error*dt;
	float rateError = (error - prevError)/(float)(dt);

	float proportional = kp * error;
	float integral = ki * errorTotal;
	float derivative = kd * rateError;
	//if error and derivative are the same sign
	// and derivative won't make div by 0 errors
	if((derivative > 0 && error > 0) || (derivative < 0 && error < 0)) {
		derivative = 0;
	}

	// Limit Integral to the Integral Active Zone
	limit(integral, INTEGRAL_ACTIVE_ZONE, -INTEGRAL_ACTIVE_ZONE);

	prevError = error;

	return proportional + integral + derivative;
}

/*
* Arm
* Motor Power
* Function
*/

// Sets All Arm Motors to Same Power Value
// Input the Desired Motor Power for All Arm Motors
void setArm(float power, int sens)
{
	//if(sens > 110*ARM_GEAR_RATIO) limit(power, ARM_POWER_LIMIT/*/3.0*/, -ARM_POWER_LIMIT);
	//else limit(power, ARM_POWER_LIMIT, -ARM_POWER_LIMIT);
	limit(power, ARM_POWER_LIMIT, -ARM_POWER_LIMIT);

	motor[A1] = power;
	motor[A2R] = power;
	motor[A2L] = power;
	motor[A3] = power;
}

/*
* Pre-Autonomous
* Sub-Functions
*/

// Clear Drive Encoders
void clearDBenc()
{
	SensorValue[DFLenc] = 0;
	SensorValue[DFRenc] = 0;
	//nMotorEncoder[DL] = 0;
	//nMotorEncoder[DR] = 0;
}

// Clear Arm Encoders
void clearAenc()
{

	SensorValue[Aenc] = 0;
}

// Clear Claw Encoders
void clearCenc()
{
	SensorValue[CLenc] = 0;
	SensorValue[CRenc] = 0;
}

/*
* Pre-Autonomous
* Function
*/

// Used to Clear Encoder Values Before the Match
void pre_auton()
{
	clearDBenc();
	clearAenc();
	clearCenc();
}

/*
* Autonomous
* Claw
* Function
*/

// Sends Motor Powers to Robot Based on Target for PID
// Input Desured Target for Each Drive Encoder
task clawPID()
{
	const float L_claw_kp = 3.3;
	const float L_claw_ki = 0.0000001;
	const float L_claw_kd = 40.0;

	const float R_claw_kp = 3.3;
	const float R_claw_ki = 0.0000001;
	const float R_claw_kd = 40.0;

	static float L_claw_error = 0;
	float L_claw_prevError = 0;
	float L_claw_errorTotal = 0;

	static float R_claw_error = 0;
	float R_claw_prevError = 0;
	float R_claw_errorTotal = 0;

	static float L_claw_sensVal, R_claw_sensVal;

	long time0 = time1[T1] - 20;
	long dt = 0;

	float motorLClawOutput, motorRClawOutput;
	static float clawTarget;
	while (true)
	{
		if(clawPIDRunning)
		{
			dt = time1[T1] - time0;
			time0 = time1[T1];

			clawTarget = clawSetPoint*CLAW_GEAR_RATIO;
			limit(clawTarget, CLAW_MAX_ROTATION, CLAW_MIN_ROTATION);

			L_claw_sensVal = SensorValue(CLenc);
			R_claw_sensVal = SensorValue(CRenc);

			motorLClawOutput = pid(L_claw_kp, L_claw_ki, L_claw_kd, clawTarget, L_claw_error, L_claw_errorTotal, L_claw_prevError, L_claw_sensVal, dt);
			motorRClawOutput = pid(R_claw_kp, R_claw_ki, R_claw_kd, clawTarget, R_claw_error, R_claw_errorTotal, R_claw_prevError, R_claw_sensVal, dt);

			limit(motorLClawOutput, CLAW_POWER_LIMIT, -CLAW_POWER_LIMIT);
			limit(motorRClawOutput, CLAW_POWER_LIMIT, -CLAW_POWER_LIMIT);

			motor[CL] = motorLClawOutput;
			motor[CR] = motorRClawOutput;
		}
		sleep(20);
	}
}

/*
* Autonomous
* Arm
* Function
*/

// Used For Arm Adjustment
// Input Desired Degree Target and Power/Speed

task armPID()
{
	static float arm_kp = 4.6;
	static float arm_ki = 0.00001;
	static float arm_kd = 45.0;

	static float arm_error = 0;
	float arm_prevError = 0;
	float arm_errorTotal = 0;

	float arm_sensVal;

	long time0 = time1[T1] - 20;
	long dt = 0;
	float armTarget;

	while (true)
	{
		if(armPIDRunning)
		{
			dt = time1[T1] - time0;
			time0 = time1[T1];

			armTarget = armSetPoint*ARM_GEAR_RATIO;
			limit(armTarget, ARM_MAX_ROTATION, ARM_MIN_ROTATION);

			arm_sensVal = SensorValue[Aenc];

			// PID Output to Arm Limited in The Set Arm Power Function
			setArm(pid(arm_kp, arm_ki, arm_kd, armTarget, arm_error, arm_errorTotal, arm_prevError, arm_sensVal, dt), arm_sensVal);
		}
		sleep(20);
	}
}

task autonArmNormal()
{
	short sens = 0;

	while(true) {
		sens = SensorValue(Aenc);

		if(sens > 100 * ARM_GEAR_RATIO)
		{
			if(autonArmPower < 0) setArm(autonArmPower, sens);
			else setArm(0, sens);
		}
		else if(sens < 0)
		{
			if(autonArmPower > 0) setArm(autonArmPower, sens);
			else setArm(0, sens);
		}
		else
		{
			if(autonArmPower > 0)
			{
				if(sens < 100*ARM_GEAR_RATIO) setArm(autonArmPower, sens);
			}
			else
			{
				limit(autonArmPower, 0, -ARM_POWER_LIMIT / 3);
				setArm(autonArmPower, sens);
			}

		}
	}
}

task autonDriveNormal() {
	while(1) {
		motor[DL] = autonDrivePower;
		motor[DR] = autonDrivePower;
		sleep(20);
	}
}

// Converts Inches to Degree Change for the Drive Wheels
// Input Desired Inch Change
float getTicks(float in)
{
	return 360.0*(in/(PI*WHEEL_DIAMETER));//627.2
}
//*rt2

// Sends Motor Powers to Robot Based on Target for PID
// Input Desired Target for Each Drive Encoder
task drivePID()
{

	static float drive_auton_kp = 0.269;
	static float drive_auton_ki = 0.0000013;
	static float drive_auton_kd = 60.0;

	static float turn_auton_kp = 0.845;
	static float turn_auton_ki = 0.00000001;
	static float turn_auton_kd = 27.0;

	static float L_drive_error = 0;
	float L_drive_prevError = 0;
	float L_drive_errorTotal = 0;

	static float R_drive_error = 0;
	float R_drive_prevError = 0;
	float R_drive_errorTotal = 0;

	long time0 = time1[T1] - 20;
	long dt = 0;

	static float L_drive_sensVal, R_drive_sensVal;

	float motorLDriveAutonOutput, motorRDriveAutonOutput;

	clearDBenc();

	isDriveDone = true;
	int itDriveSetReached = 0;
	bool ctrStarted = false;

	while (true)
	{
		if(!isDriveDone) {
			float kp, ki, kd;
			//if turning, the two wheels will not be set to the same thing
			if((int)(driveSetPointL/abs(driveSetPointL)) != (int)(driveSetPointR/abs(driveSetPointR))) {
				kp = turn_auton_kp;
				ki = turn_auton_ki;
				kd = turn_auton_kd;
			}
			//if driving straight
			else
			{
				kp = drive_auton_kp;
				ki = drive_auton_ki;
				kd = drive_auton_kd;
			}



			dt = time1[T1] - time0;
			time0 = time1[T1];

			//L_drive_sensVal = (360.0/627.2)*nMotorEncoder[DL];
			//R_drive_sensVal = (360.0/627.2)*nMotorEncoder[DR];

			L_drive_sensVal = SensorValue[DFLenc];
			R_drive_sensVal = SensorValue[DFRenc];

			motorLDriveAutonOutput = pid(kp, ki, kd, driveSetPointL, L_drive_error, L_drive_errorTotal, L_drive_prevError, L_drive_sensVal, dt);
			motorRDriveAutonOutput = pid(kp, ki, kd, driveSetPointR, R_drive_error, R_drive_errorTotal, R_drive_prevError, R_drive_sensVal, dt);

			limit(motorLDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);
			limit(motorRDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);

			motor[DL] = motorLDriveAutonOutput;
			motor[DR] = motorRDriveAutonOutput;

			if(!ctrStarted && abs(motorLDriveAutonOutput) < DRIVE_CLOSE_ENOUGH  && abs(motorRDriveAutonOutput) < DRIVE_CLOSE_ENOUGH) {
				ctrStarted = true;
			}
			if(ctrStarted) itDriveSetReached++;

			if(itDriveSetReached > DRIVE_EXTRA_IT) {
				isDriveDone = true;
				ctrStarted = false;
				itDriveSetReached = 0;
			}
		}
		wait1Msec(20);
	}
}

void WaitUntilDriveDone() {
	int t0 = time1[T1];
	//only allow 4 seconds max
	while(!isDriveDone && time1[T1] - t0 < 4000) {
		sleep(20); // wait until drive finishes
	}
}


// Used For Basic Motion (Forward/Backward)
// Input Desired Inch/degree Movement, Direction, and Power/Speed
void setDriveSetPoint(float setPoint, Dir dir)
{
	switch(dir)
	{
	case FORWARD:
		driveSetPointR = getTicks(setPoint);
		driveSetPointL = driveSetPointR;
		break;

	case BACKWARD:
		driveSetPointR = -getTicks(setPoint);
		driveSetPointL = driveSetPointR;
		break;

	case CW:
		driveSetPointR = -getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
		driveSetPointL = -driveSetPointR;
		break;

	case CCW:
		driveSetPointR = getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
		driveSetPointL = -driveSetPointR;
		break;

	case LEFT:
		// Placeholder for Possible Future H-Drive Implementation
		break;

	case RIGHT:
		// Placeholder for Possible Future H-Drive Implementation
		break;
	}
	clearDBenc();
	isDriveDone = false;
	WaitUntilDriveDone();
	motor[DL] = 0;
	motor[DR] = 0;
}


/*
*
* Main
* Autonomous
* Task
*
*/

//grab cube, knock stars off low fence, then right high fence
//start on right side
void auton1() {

	clawSetPoint = -80;
	sleep(500);
	//setDriveSetPoint(12, FORWARD);
	//setDriveSetPoint(12, BACKWARD);
	startTask(autonDriveNormal);
	autonDrivePower = 127;
	sleep(700);
	autonDrivePower = -127;
	sleep(700);
	stopTask(autonDriveNormal);

	setDriveSetPoint(35, FORWARD);
	clawSetPoint = 15;
	sleep(1000);
	armSetPoint = 30;
	sleep(300);
	setDriveSetPoint(90, CCW);

	armPIDRunning = false;
	startTask(autonArmNormal);
	autonArmPower = 20;

	setDriveSetPoint(18, BACKWARD);
	autonArmPower = ARM_POWER_LIMIT;
	sleep(790);
	clawSetPoint = -75;
	autonArmPower = ARM_POWER_LIMIT;
	sleep(710);
	autonArmPower = -30;

	autonArmPower = 0;
	stopTask(autonArmNormal);

	//knock stuff off fence
	setDriveSetPoint(12, FORWARD);
	armPIDRunning = true;
	armSetPoint = ARM_LOW_FENCE_ANGLE;
	setDriveSetPoint(180, CW);
	setDriveSetPoint(20, FORWARD);

	//knock more stuff off fence
	setDriveSetPoint(12, BACKWARD);
	setDriveSetPoint(90, CW);
	setDriveSetPoint(45, FORWARD);
	setDriveSetPoint(90, CCW);
	armSetPoint = ARM_HIGH_FENCE_ANGLE;
	setDriveSetPoint(38, FORWARD);

	setDriveSetPoint(24, BACKWARD);
	armPIDRunning = false;
	setArm(0, SensorValue[Aenc]);

	sleep(1000);


}

// Runs the Autonomous Code Durring the Autonomous Portion of the Competition
task autonomous()
{
	pre_auton();
	isAuton = true;
	armPIDRunning = true;
	clawPIDRunning = true;

	startTask(clawPID);
	startTask(armPID);
	startTask(drivePID);


	//change clawSetPoint and ArmSetPoint  directly using values in degrees
	//change driveSetPoint by calling setDriveSetpoint()
	//note: setDriveSetPoint() will wait until the previous setpoint has been reached

	// arm and claw don't wait to finish before moving to next command
	// so, to move arm and drive at the same time, set the arm then call the drive function

	auton1();

	//stopAllTasks();
	while(true) {
		sleep(9999999);
	}
}

/*
* User Control
* Claw
* Sub-Task
*/

// Controls the Claw of the Robot During the User Control Portion of the Competition
task updateClawUserControl()
{
	int CLsens, CRsens;

	int lastTime = 0;
	while(true)
	{
		CLsens = SensorValue(CLenc);
		CRsens = SensorValue(CRenc);

		if (vexRT[Btn8R] == 1 || vexRT[Btn8DXmtr2] == 1) {
			clawPIDRunning = false;
			// to give other thread time,  stop pid
			sleep(30);
			motor[CL] = 0;
			motor[CR] = 0;
			clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
			lastTime = time1[T1];
		}
		else {
			if (vexRT[Btn5U] == 1 || vexRT[Btn6UXmtr2] == 1)
			{
				clawPIDRunning = false;
				// open claw fast
				if(CLsens > CLAW_MIN_ROTATION) motor[CL] = -127;
				if(CRsens > CLAW_MIN_ROTATION) motor[CR] = -127;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn6U] == 1 || vexRT[Btn6DXmtr2] == 1)
			{
				clawPIDRunning = false;
				// close claw fast
				if(CLsens < CLAW_MAX_ROTATION) motor[CL] = 127;
				if(CRsens < CLAW_MAX_ROTATION) motor[CR] = 127;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn6D] == 1 || vexRT[Btn5DXmtr2] == 1)
			{
				clawPIDRunning = false;
				// close claw slow
				if(CLsens < CLAW_MAX_ROTATION) motor[CL] = 30;
				if(CRsens < CLAW_MAX_ROTATION) motor[CR] = 30;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn5D] == 1 || vexRT[Btn5UXmtr2] == 1)
			{
				clawPIDRunning = false;
				// open claw slow
				if(CLsens > CLAW_MIN_ROTATION) motor[CL] = -30;
				if(CRsens > CLAW_MIN_ROTATION) motor[CR] = -30;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else
			{
				if(time1[T1] - lastTime < 300) {
					clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				}
				clawPIDRunning = true;
			}
		}

		sleep(20);
	}
}

/*

if(time1[T1] - lastTime < 300) {
					clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				}
























* User Control
* Arm
* Sub-Task
*/

// Controls the Arm of the Robot Durring the User Control Portion of the Competition
task armUserControl()
{
	armPIDRunning = false;
	startTask(armPID);
	const int armChThreshold = 15;

	float armTarget = SensorValue[Aenc];
	short sens = SensorValue(Aenc);

	long dt;
	long time0 = time1[T1] - 20;

	long lastTime = 0;
	while (true)
	{
		dt = time1[T1] - time0;
		time0 = time1[T1];

		sens = SensorValue(Aenc);

		if ((vexRT[Btn8UXmtr2] == 1) || (vexRT[Btn7L] == 1))
		{
			armPIDRunning = false;
			armTarget = SensorValue(Aenc);
			setArm(0, SensorValue(Aenc));
		}
		else
		{
			if(vexRT[Btn8D] == 1)
			{
				armPIDRunning = true;
				armTarget = SensorValue(Aenc);
				armSetPoint = ARM_LOW_FENCE_ANGLE;
			}
			else if(vexRT[Btn8R] || vexRT[Btn8L])
			{
				armPIDRunning = true;
				armTarget = SensorValue(Aenc);
				armSetPoint = ARM_MID_ANGLE;
			}
			else if(vexRT[Btn8U] == 1)
			{
				armPIDRunning = true;
				armTarget = SensorValue(Aenc);
				armSetPoint = ARM_HIGH_FENCE_ANGLE;
			}
			else if (SensorValue[Aenc] > ARM_MAX_ROTATION)
			{
				armPIDRunning = false;
				armTarget = SensorValue(Aenc);
				if (vexRT[Btn7U] == 1)
				{
					setArm(vexRT[Ch2], sens);
				}
				else if (vexRT[Ch2] <= -armChThreshold)
				{
					setArm(vexRT[Ch2], sens);
				}
				else
				{
					if(sens < 130*ARM_GEAR_RATIO) setArm(0, sens);
					else setArm(-10, sens);
				}
			}
			else if (SensorValue[Aenc] <= ARM_MIN_ROTATION) {
				short channel2 = vexRT[Ch2];
				armPIDRunning = false;
				if (vexRT[Btn7D] == 1) {
					if (vexRT[Ch2] <= -armChThreshold)
					{
						setArm(limit(channel2, ARM_POWER_LIMIT, -ARM_POWER_LIMIT), sens);
					}
				}
				else if (vexRT[Ch2] <= -armChThreshold)
				{
					limit(channel2, ARM_POWER_LIMIT, -15);
					setArm(vexRT[Ch2], sens);
				}
				else
				{
					setArm(vexRT[Ch2], sens);
				}
			}
			else
			{
				armPIDRunning = false;
				if (abs(vexRT[Ch2]) > armChThreshold)
				{
					armTarget = SensorValue(Aenc);
					setArm(vexRT[Ch2], sens);
				}
				else
				{
					armPIDRunning = true;
					//if(sens < 70*ARM_GEAR_RATIO) setArm(25, sens);
					//if(sens < 95*ARM_GEAR_RATIO) setArm(15, sens);
					//if(sens < 70*ARM_GEAR_RATIO) setArm(0, sens);
					//if(sens < 95*ARM_GEAR_RATIO) setArm(0, sens);
					//else if(sens < 130*ARM_GEAR_RATIO) setArm(0, sens);
					//else setArm(-10, sens);
				}
			}
		}
		armSetPoint = armTarget/ARM_GEAR_RATIO;
		sleep(20);
	}
}

/*
* User Control
* Drive
* Sub-Task
*/

// Controls the Drive of the Robot Durring the User Control Portion of the Competition
task driveUserControl ()
{

	float Y1 = 0, X1 = 0;

	const int driveChThreshold = 15;

	float motorLDriveUserOutput, motorRDriveUserOutput;

	while (true)
	{


		if ((abs(vexRT[Ch3]) > driveChThreshold) || (abs(vexRT[Ch4]) > driveChThreshold))
		{
			Y1 = vexRT[Ch3];
			X1 = vexRT[Ch4];
		}
		else
		{
			X1 = 0;
			Y1 = 0;
		}

		motorLDriveUserOutput = Y1 + X1;
		motorRDriveUserOutput = Y1 - X1;

		short amountOfTurning = abs(motorLDriveUserOutput - motorRDriveUserOutput) / TURN_CONST;

		motorLDriveUserOutput -= motorLDriveUserOutput > 0 ? amountOfTurning  : -amountOfTurning;
		motorRDriveUserOutput -= motorRDriveUserOutput > 0 ? amountOfTurning  : -amountOfTurning;


		limit(motorLDriveUserOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);
		limit(motorRDriveUserOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);

		motor[DL] = motorLDriveUserOutput;
		motor[DR] = motorRDriveUserOutput;

		wait1Msec(20);
	}
}

/*
*
* Main
* User Control
* Task
*
*/

// Runs the User Control Code Durring the User Control Portion of the Competition
task usercontrol()
{
	isAuton = false;
	startTask(clawPID);
	startTask(updateClawUserControl);
	startTask(armUserControl);
	startTask(driveUserControl);

	while (true) sleep(9999);
}
